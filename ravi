#include <cstdio>
#include <queue>
#include <vector>

using namespace std;

typedef pair<int, int> ii;

const int N = 1010, D = 1000010;
int n, m, ss, sp, ans = D, d[3][D];
char s[N][N];
bool f[D];
vector<ii> v[D];

void dijkstra(int be, int* d)
{
    priority_queue<ii> q;
    fill(f, f + n * m + 1, 0);
    q.push({0, be});
    while (!q.empty())
    {
        int di = q.top().first, c = q.top().second; q.pop();
        if (f[c]) continue;
        f[c] = true; d[c] = -di;
        for (auto i : v[c]) q.push({di - i.second, i.first});
    }
}

int main()
{
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%s", s[i] + 1);
    for (int i = 1, k = 1; i <= n; i++)
        for (int j = 1; j <= m; j++, k++)
        {
            ii pa = {k, s[i][j] == '#'};
            if (i > 1) v[k - m].push_back(pa); else
            if (!f[k]) v[0].push_back(pa), f[k] = true;
            if (i < n) v[k + m].push_back(pa); else
            if (!f[k]) v[0].push_back(pa), f[k] = true;
            if (j > 1) v[k - 1].push_back(pa); else
            if (!f[k]) v[0].push_back(pa), f[k] = true;
            if (j < m) v[k + 1].push_back(pa); else
            if (!f[k]) v[0].push_back(pa), f[k] = true;
            if (s[i][j] == 'S') ss = k;
            if (s[i][j] == 'P') sp = k;
        }
    dijkstra(0, d[0]);
    dijkstra(ss, d[1]);
    dijkstra(sp, d[2]);
    for (int i = 1, k = 1; i <= n; i++)
        for (int j = 1; j <= m; j++, k++)
        {
            int ke = d[0][k] + d[1][k] + d[2][k];
            if (s[i][j] == '#') ke -= 2;
            ans = min(ans, ke);
        }
    printf("%d", ans);
    return 0;
}
